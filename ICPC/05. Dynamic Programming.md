# 05. Dynamic Programming

## 동적 계획법 Dynamic Programming
> 하나의 큰 문제를 여러 개의 작은 문제들로 **나누어서** 그 결과를 **저장**하여 다시 큰 문제를 해결
1) 큰 문제를 작은 문제로 쪼갠다
2) 그 답을 저장해놓고 재활용한다

## 사용 조건
### 최적 부분 구조 Optimal Substructure
> 부분 문제의 **최적** 결과값 + 전체 문제의 **죄적** 결과

ex) A->B까지의 가장 짧은 경로 찾기
- A->X / X->B가 가장 짧은 경로라면 전체 최적 경로도 A->X->B

### 중복되는 부분 문제 Overlapping Substructure
> 동일한 작은 문제들이 **반복**하여 나타나는 경우
- 부분 문제가 반복적으로 나타나지 않으면 재사용 불가능
- 시간복잡도 대폭 감소

## 문제 해결 과정
### 1) DP로 풀 수 있는 문제인지 확인
- 특정 데이터 내 **최댓값/최솟값** 계산
- 특정 조건 내 데이터 **셀 때**
- 도형, 수학

### 2) 문제의 변수 state 파악
> 주로 문제에서 **구해야 하는 값**을 보고 결정

- 결과값을 바뀌게 만들어주는 수 
- 매개변수

### 3) 변수 간 관계식 만들기 (점화식)
- 현재 변수값과 이전/다음 변수값과의 관계식
- 관계식이 있어야 반복/재귀를 통해 문제 해결 가능

### 4) 메모하기 memorization / tabulation
> 변수값에 따른 결과 저장

- 결과를 저장할 **배열** 생성
- 결과가 나올 때마다 배열 내에 저장
- 저장된 값 **재사용**
- 변수의 개수에 따라 배열 차원이 1~3차원

### 5) 초기(기저) 상태 파악하기
> 가장 **작은** 문제의 상태 파악

### 6) 구현하기
#### 1) Bottom-up 
> 반복문 사용

- dp[0] > dp[n]을 목표로 함
- 함수를 재귀 호출하지 않아 시간 & 메모리를 절약할 수 있다

```
void fibo() {
    dp[0] = 0;
    dp[1] = 1;
    for (int i=2; i<=90; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
}
```

#### 2) Top-Down
> 재귀 사용

- f(n)을 찾기 위해 dp[0] 상태까지 내려감
- 점화식을 한 눈에 볼 수 있다
```
ll fibo(int n) {
    if (n==0 | n==1){
        return dp[n] = n;
    }
    if (dp[n] == 0){
        dp[n] = fibo(n-1) + fibo(n-2);
    }
    return dp[n];
}
```

## 문제 해결 연습
1) 완전탐색, 백트래킹 등의 아이디어로 문제를 해결할 수 있는지 확인
2) 일단 재귀함수로 완전탐색 프로그램 작성(top-down)
- 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있는지 확인
- 가능하다면 메모 기법을 이용해 코드 계산

## 문제 유형
### 1) LIS 
> 가장 긴 증가하는 부분 수열
- 부분 수열 : 어떠한 수열에서 일부 원소를 뽑아내서 만든 새로운 수열(연속되지 않아도 됨!)
- 항상 하나로 결정되지는 않는다
- 주로 bottom-up으로 구현

### 2) LCS 
> 가장 긴 공통 부분 수열
- 변수 : 두 문자열의 idx i, j
- dp[i][j] = s1[0..i]와 s2[0..j]의 LCS 길이
- 기저 상태 : dp[0][0] = 0
- 점화식
```
1) 같으면 dp[i][j] = dp[i-1][j-1] + 1
2) 다르면 dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

### 3) Knapsack 
> 배낭 문제

### 0-1 knapsack 문제
- 변수 i, j (물건 번호, 최대 배낭 무게)
- dp[i][j] : i번쨰 물건까지 고려했고, 가방의 무게가 j일 때, 가방에 담긴 물건들의 최대 가치
- 기저 상태 : dp[0][j] = 0
- 점화식
```
1) 무거워서 못 넣는 경우 
dp[i][j] = dp[i-1][j]
2) 담을 수 있는 경우 (담았을 떄 / 담지 않았을 때)
dp[i][j] = max(dp[i-1][j-W[i]+V[i], dp[i-1][j])
```